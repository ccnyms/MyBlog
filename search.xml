<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二、变量、值类型、语句基本规则]]></title>
    <url>%2F2020%2F03%2F05%2F%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%80%BC%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[𝟙.变量（variable）变量声明： 声明、赋值分解 12var a;a = 1; 单一 var 12var a = 1, b = 2; 开发规范：单一 var 模式，每个变量用逗号隔开，同时换行。 命名规则： 变量名必须以英文字母、_、$开头 变量名可以包括英文字母、_、$、数字 不可以用系统的关键字、保留字作为变量名。 𝟚.值类型：原始值与引用值原始值 不可改变， 存储在 stack（栈）：先进的后出来。 五大值类型： Number — 数字 Boolean — 布尔 String — 字符串 undefined — 未定义（未被赋值的变量值输出时会有这个结果） null — 空（可以用来占位） 引用值 存储在 heap（堆）：怎么进的怎么出。 值类型： Array — 数组 Object — 对象 Function — 函数 RegExp — 正则 Date — 日期 区别 原始值和引用值唯一的不同是赋值形式不同。 原始值以值的拷贝方式赋值，原值是不可变的。操作都在副本上。引用值以引用的拷贝方式赋值，原值是可变的。引用的是地址，操作还是在原来的地方，除非换一个地址（赋新值）。 原始值一旦赋值，不可更改。无论是原值增删，还是新的赋值，都会直接存放到新的地方，原值不动。在操作上，表现为原始值和对应栈名复制一份到新的地方，同时之前的对应栈名初始化，值不动，增删和新赋值都在副本上进行。如： 在栈内存中声明一个叫 num 的房间，放入值 1 在栈内存中声明一个叫 num1 的房间，拷贝 num 的值 1 放入 num1 将 num 及其值 1 拷贝到一个新的房间，然后修改值为 2，原来的房间名初始化为 1005，原值 1 依然留在该房间，不会发生变化 12345var num = 1, num1 = num;num = 2;console.log(num1); // 1 引用值赋值之后，如果是在原值上增删，会直接修改原值。如果是新的赋值，就会直接存放到新的地方，原值不动。 原值增删： 在栈内存中声明一个叫 arr 的房间，在堆内存中一个房间里放入值 [1, 2]，然后 arr 房间内放入这个值的==堆内存地址==heap1001 在栈内存中声明一个叫 arr1 的房间，然后直接拷贝 arr 房间内存放的地址heap1001，获得 arr 的值 此时 arr 与 arr1 指向同一个值的地址heap1001 arr 增加新值 3，直接在heap1001存放的值里增加，变为 [1, 2, 3] 此时 arr 与 arr1 共同指向的值变为 [1, 2, 3] 12345var arr = [1, 2], arr1 = arr;arr.push(3);document.write(arr1); // [1, 2, 3] 赋新值： 在栈内存中声明一个叫 arr 的房间，在堆内存中一个房间里放入值 [1, 2]，然后 arr 房间内放入堆内存地址heap1001 在栈内存中声明一个叫 arr1 的房间，然后直接拷贝 arr 房间内存放的地址，获得 arr 的值 此时 arr 与 arr1 指向同一个值的地址heap1001 arr 赋新值，在堆内存中另一个房间里放入新值 [1, 2, 3]，然后 arr 房间内删除原来的地址heap1001，放入这个新值的堆内存地址heap1002 此时 arr 指向的值为 [1, 2, 3]，arr1 指向的值为 [1, 2] 1234var arr = [1,2], arr1 = arr;arr = [1,2,3];document.write(arr1); // [1, 2] 𝟛. JS 语句基本规则 语句后面要用分号;结束。注意，下列三种语句不用加分号： 函数： function test() {} for 循环：for() {} if 语句：if() {} 一个 HTML 文件中可以放多个 JS 代码块，代码块内的规则可以互通。如果某个代码块内出现 JS 语法错误，会引发该代码块内的后续代码终止，但不会影响其他 JS 代码块，目前有两种错误： 低级错误：语法解析错误，整个代码块都不会执行。如：使用了中文标点符号：Uncaught Syntax Error: …… 逻辑错误：标准错误，会执行到该代码块最后一行正确代码再终止。如：没有声明变量，直接使用：Uncaught Reference Error: …… 书写格式要规范，= + / -两边都应该有空格。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、JavaScript 基础知识]]></title>
    <url>%2F2020%2F03%2F03%2F%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[𝟙.浏览器 Mosaic 是互联网历史上第一个获普遍使用和能够显示图片的网页浏览器。于 1993 年问世。 浏览器组成： shell （外形）部分 内核部分：渲染引擎（语法规则和渲染），js 引擎，其他模块 主流浏览器及其内核： IE -&gt; Trident Chrome -&gt; Blink Opera -&gt; Blink Safari -&gt; Webkit Firefox -&gt; Gecko 2001 年的 IE6 浏览器，首次实现对 JavaScript 引擎的优化和分离。 2008 年 Google 发布最新浏览器 Chrome，它是采用优化后的 JavaScript 引擎，引擎代号 V8，因能把 JavaScript 代码直接转化为机械码来执行，进而以速度快而闻名。 𝟚. 特性 程序设计语言分为解释型和编译型两大类。 C 或 C++ 等语言需要一个编译器（compiler）。编译器是一种程序，能够把用 Java 等高级语言编写出来的源代码翻译为直接在计算机上执行的文件。 解释型程序设计语言不需要编译器，它们只需要解释器。对于 JavaScript，浏览器负责完成有关的解释和执行工作。 特点： 解释型语言 — （不需要编译成文件）跨平台。 单线程 — 同一时间只能干一件事。 弱类型语言 — 存放的数据类型可变。 我们把 JavaScript 中的核心部分称为 ECMAScript，加上 BOM（浏览器对象模型）与 DOM（文档对象类型），三者共同组成了 JavaScript。 ECMA-262 标准规定了这门语言的如下组成部分：语法、类型、语句、关键字、保留字、操作符、对象。 浏览器对象模型（BOM，Browser Object Model），提供与浏览器交互的方法和接口。 文档对象内容（DOM，Document Object Model），提供访问和操作网页内容的方法和接口。 异步（asynchronous）：同时执行，类似于有很多条路一起走，可以同时出发。 同步（synchronous）：分次执行，类似于只有一条路走，这个走完了下个才能走。 JavaScript 执行队列 -&gt; 执行过程：轮转时间片。 单线程模拟多线程。 类似吃饭，吃一口米饭，吃一口茄子，再吃一口排骨，再吃一口米饭，再吃一口米饭，再吃一口茄子，顺序完全随机，在足够快的时间内，肉眼可见菜和饭在同时减少。 比如 js 引擎要执行任务 1 和任务 2，js 引擎会把任务 1 和任务 2 切成无数个片段，然后把这些片段随机排成一个队列送入引擎执行，直到被执行完。 JavaScript 可正常计算的范围：小数点前 16 位，后 16 位。 JS 计算精度不准，是纯粹的 bug，所以在 JS 中应尽量避免小数操作。 123var num = 0.14 * 100;console.log(num); // 14.000000000000002 如果需要计算，那么采用Math.floor()（向下取整）或Math.ceil()（向上取整）方法。 123456789// 向上取整，无论小数是多少，都向前进 1var num = Math.ceil(123.234);console.log(num); // 124// 向下取整，无论小数是多少，都不要了var num1 = Math.floor(123.999);console.log(num1); // 123 Math.random()方法可以随机产生一个 0 ～ 1 之间的开区间的数。 12345var num = Math.random();console.log(num); // 0.4322440432127299console.log(num); // 0.5216225452503296 toFixed()方法可以把 Number 四舍五入为指定小数位数的数字。 12345var num = 123.45678; demo = num.toFixed(2); console.log(demo); // 123.46 引入 JavaScript： 页面内嵌&lt;script&gt;&lt;/script&gt;标签 外部引入&lt;script src=location&gt;&lt;/script&gt; 页面中，可以存在多个&lt;script&gt;标签，执行顺序从上到下。只要不存在 defer 和 async 属性，浏览器都会按照 它们在页面中出现的先后顺序依次进行解析。 注意，如果有外部 js 文件，那么这个 script 标签里如果再写 js 代码，也是不会执行的，会被直接忽略。基于这个特性，在开发时偶尔会用来存储一些代码。 在下面再写一个 script 标签，然后里面写代码是可以的。 传统的做法是所有&lt;script&gt;标签都放在&lt;head&gt;中，这意味着必须等到全部 js 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到&lt;body&gt;标签时才开始呈现内容）。 为了避免这个问题，现代 Web 应用程序一般都把全部 js 引用放在&lt;body&gt;中页面内容的后面。这样，在解析包含的 js 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。 为符合 Web 标准中结构、样式、行为相分离的原则，通常会采用外部引入。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo!This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
