<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[（四）typeof、类型转换、进制]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%9B%9B%E3%80%81typeof%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[typeof 操作符 作用：区分数据类型（六种） number string boolean undefined object（泛指引用值，数组 array 和 null 都属于此类） function 原始值：number/string/boolean/undefined/null 引用值：array/object/function null 最初是作为代替空对象的形式出现（给对象占位），所以它的数据类型是 object 写法：typeof() 或者 typeof 内容 12345678var num = function() &#123;&#125;;console.log(typeof(num)); // functionvar mul = null;console.log(typeof mul); // objectvar arr = [];console.log(typeof(arr)); // objcet 注意： 任何变量未经声明就使用的话，会直接报错。 如果放入 typeof 操作符中，不会报错，会直接返回undefined。 这个返回值undefined的类型是字符串。 1console.log(typeof(a),typeof(typeof(a))); // undefined string 任何情况下，返回的六种类型的值都是字符串类型。 12345678910111213141516var str = 'abc';console.log(typeof(str), typeof(typeof(str))); // string stringvar bool = true;console.log(typeof(bool), typeof(typeof(bool))); // boolean stringvar num = 7;console.log(typeof(num), typeof(typeof(num))); // number stringvar obj = &#123;&#125;;console.log(typeof obj, typeof(typeof obj)); // object stringvar fn = function() &#123;&#125;;console.log(typeof fn, typeof(typeof fn)); // function stringconsole.log(typeof undefined, typeof(typeof undefined)); // undefined string 类型转换显示 Number( )：将括号里的内容转换成数字/数字类型。 undefined、字符串（除了字符串类型的数字）、NaN-&gt; NaN true -&gt; 1 false、&quot;&quot;、null -&gt; 0 &quot;123&quot; -&gt; 123（字符串类型的数字直接转换类型，数值不变） 1234567891011var num = Number(true); // 布尔类型console.log(typeof(num),num); // number 1var num = Number('true'); // 字符串类型console.log(typeof(num),num); // number NaNconsole.log(Number('123abc')); // NaNconsole.log(Number(null)); // 0 parseInt (string, radix)：（integer：整数） 第一个作用：string 参数，转换成整值（如果前面是数字，从数字位开始看，直到非数字位截止，返回数字位） 第二个作用：radix 进制，以此进制为基底，将值转换为十进制，取值：2～36，选填。划重点：你填的多少，进制就是多少。从你填的转为十进制。目标进制（你填写的进制） &lt;==&gt; 十进制 常见转换： &quot;123.7&quot;-&gt; 123 &quot;123abc&quot; -&gt; 123（首位是数字的话，从数字位开始看，在非数字位截断） 其他 -&gt; NaN 12345678910111213var num = parseInt(true);console.log(typeof(num) + ': ' + num); // number: NaNconsole.log(parseInt('123.9')); // 123console.log(parseInt('123abc')); // 123var num = parseInt('abc123');console.log(typeof(num) + ': ' + num); // number: NaNvar num = parseInt('a',16); // a 目前为十六进制数，要转化为十进制数console.log(typeof(num) + ': ' + num); // number: 10 parseFloat(string)：类似 parseInt 方法，转换成浮点数（正常的小数）。 12345678var num = parseFloat('123.45');console.log(typeof(num) + ': ' + num); // number: 123.45var num = parseFloat('123.45abc');console.log(typeof(num) + ': ' + num); // number: 123.45var num = parseFloat('abc123.45');console.log(typeof(num) + ': ' + num); // number : NaN 参数.toString(radix)：将参数转换成字符串 radix 进制，以十进制为基底，转换成填写的进制，选填。十进制&lt;==&gt;目标进制（你填写的进制）划重点：你填的多少，就是想要多少。从十进制转为你填的。 undefined 和 null 不能用该方法，使用会直接报错（因为它俩没有原型，而其他原始值经过包装类后成为原始值对象，都有原型） 123456789var demo = 123;var num = demo.toString();console.log(typeof(num) + ': ' + num); // string: 123var demo = 10;var num = demo.toString(16);// 10 目前为十进制数，要转化为十六进制console.log(typeof(num) + ': ' + num); // string: a 注意：如果直接使用123.toString()是不可以的，会直接报错。因为系统会首先将这个语句识别为浮点型，数学计算的点.优先级最高，所以识别成浮点数，小数点后是字母是肯定报错的。 123var num = 123.toString();console.log(num); // 报错，Uncaught SyntaxError: Invalid or unexpected token String( )：将括号里的内容转换成字符串 1234567var num = String(123);console.log(typeof(num) + ': ' + num); // string: 123var num = String(true);console.log(typeof(num)+': '+num); // string: true Boolean( )：转换成布尔值 undefined / null / NaN / “” / 0 / flase -&gt; false 1234567891011var num = Boolean('');console.log(typeof(num) + ': ' + num); // boolean: falsevar num = Boolean(0);console.log(typeof(num) + ': ' + num); // boolean: falsevar num = Boolean('0');console.log(typeof(num) + ': ' + num); // boolean: true 隐式 内部原理：调用显示类型转换。原理：调用 Number( ) 方法转为数字，然后和 NaN 比对。 isNaN() ：判断参数是不是 NaN，返回结果为 boolean 类型。常用转换：NaN / undefined / 字符串（除了字符串类型的数字） -&gt; NaN 1234567891011console.log(isNaN(NaN)); // trueconsole.log(isNaN(123)); // falseconsole.log(isNaN('123')); // falseconsole.log(isNaN('aa')); // trueconsole.log(isNaN(undefined)); // trueconsole.log(isNaN(null)); // false ++/--、+/-（一元正负）：转换为 number 类型。原理：调用 Number( )。一元正负，只有一边有参数，如”+ a” / “- b” 1234567891011121314var a = 'abc';a++;console.log(typeof(a), a);// number NaNvar b = '123';b++;console.log(typeof(b), b);// number 124var c = null;c--;console.log(typeof(c), c);// number -1var d = +'abc';console.log(typeof(d), d);//number NaN + （加号）：若加号两边存在一个字符串，将另一个也转为字符串，转为 string 类型。调用 String 方法。其他情况下（number / undefined / null / boolean），转为 number 类型。调用 Number 方法。 12var a = 1 +'abc';console.log(typeof(a), a);// string 1abc 12var a = false + 1;console.log(typeof(a), a);// number 1 -、*、/、%：转为 number 类型。原理：调用 Number 方法 12345678var a = '1' * 1;console.log(typeof(a), a);// number 1var b = null / 1;console.log(typeof(b), b);// number 0var c = 'abc' - 1;console.log(typeof(c), c);// number NaN &amp;&amp;、||：过程中转为 boolean 类型进行比较，结果返回表达式的值（值本身是什么类型就返回什么类型）。 !：结果返回 boolean 类型。 1234567891011var num = 'abc' &amp;&amp; 2; console.log(typeof(num), num);// number 2var num = 'abc' &amp;&amp; 'def'; console.log(typeof(num), num);// string defvar num = null &amp;&amp; 4;console.log(typeof(num), num);// object nullvar num = !!'a';console.log(typeof(num), num);// boolean true &lt;、&gt;、&lt;=、&gt;= ： 两边都是字符串时，比较 asc 码，返回 boolean 类型。 其他情况下，调用 Number( )，先转换为数字进行比较，结果返回 boolean 类型。 undefined 和 null 除外，见特殊情况。 ==、!= ：若两边均为对象，对比它们的引用是否相同，返回 boolean 类型。其他情况下，调用 Number 方法，两边转为数字进行比较，结果返回 boolean 类型。 12345678// 引用值，两个不同的地址引用（不同房间）：console.log(&#123;&#125; == &#123;&#125;); // false// 同一个地址引用：var obj = &#123;&#125;;var obj1 = obj;console.log(obj == obj1); // true 特殊情况： undefined 和 null 既不大于 0，也不小于 0，更不等于 0。 undefined == null NaN !== NaN 12345678910console.log(undefined &gt; 0); // falseconsole.log(undefined &lt; 0); // falseconsole.log(undefined == 0); // falseconsole.log(null &gt; 0); // falseconsole.log(null &lt; 0); // falseconsole.log(null == 0); // falseconsole.log(undefined == null);// trueconsole.log(NaN == NaN);// false 例： 12345678// false == 0, true == 1, 0 &gt; 1 -&gt; falseconsole.log(false &gt; true); // false// 先判断 1 &gt; 10 -&gt; false, false == 0, 0 &gt; 0 -&gt; falseconsole.log(1 &gt; 10 &gt; 0); // false// 2 &gt; 3 -&gt; false, false == 0, 0 &lt; 1 -&gt; trueconsole.log(2 &gt; 3 &lt; 1); // true 不发生类型转换： === !== 常用转换汇总 Boolean()：undefined、null、NaN、””、0、false -&gt; false Number()：（千方百计变成数字） undefined / 字符串（除了字符串类型的数字）/ NaN -&gt; NaN true -&gt; 1 false / “” / null -&gt; 0 “123” -&gt; 123 （字符串类型的数字直接转换类型，数值不变） parseInt (string, radix)：（只要整数，不管其他） “123.7” -&gt; 123 “123abc” -&gt; 123（首位是数字的话，从数字位开始看，在非数字位截断） 其他 -&gt; NaN 例 1：关于 parseInt() 方法 1234567891011121314console.log(typeof parseInt('123abc'), parseInt('123abc')); // number 123console.log(parseInt('123.7')); // 123console.log(typeof parseInt(undefined), parseInt(undefined)); // number NaNconsole.log(parseInt(null)); // NaNconsole.log(parseInt(NaN)); // NaNconsole.log(parseInt('abc123')); // NaNconsole.log(parseInt('')); // NaNconsole.log(parseInt(true)); // NaNconsole.log(parseInt(false)); // NaN 例 2： 12345678910var str = false + 1; // 0 + 1console.log(str); // 1var demo = false == 1; // 0 !== 1 -&gt; falseconsole.log(demo); // falseconsole.log(11 + '11' * 2 == 33);// true// 11 + 22 例 3: 123456789101112console.log(typeof(a) &amp;&amp; -true + (+undefined) + ''); // 'NaN'// 左边：typeof(a) -&gt; 'undefined'// &amp;&amp; 优先级低于算术运算符，放在最后处理// 右边：-true + (+undefined) + '' -&gt; -1 + NaN + '' -&gt; NaN + '' -&gt; 'NaN'// 'undefined' &amp;&amp; 'NaN'// 一真返二// 'NaN'if(typeof(a) &amp;&amp; -true + (+undefined) + '')&#123; console.log('是否能输出');&#125;// 条件内返回的是字符串的'NaN'，为 true，可以执行 例 4: 123!!' ' + !!'' - !!false || console.log('能吗？');// 左边：true + false - false -&gt; 1 + 0 - 0 = 1// 1 为真，会直接返回 1，|| 后面的语句不会执行 进制特点 进制也就是进位计数制，是人为定义的带进位的计数方法。对于任何一种进制—— X 进制，就表示每一位置上的数运算时都是逢 X 进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，X 进制就是逢 X 进位。 比如十六进制：1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f。如果 f + 1，那么按照逢十六进一的规则，个位数变为 0，然后向前进一位，十位数变为 1。那么：f + 1 = 10，这里的 10（一零），就代表十进制里的 16。 比如二进制：0, 1。如果 1 + 1，按照逢二进一的规则，个位数变为 0 ，十位数变为 1，1 + 1 = 10，这里的 10（一零），代表十进制里的 2。 进制转换 十进制 -&gt; X 进制：除。数除以 X，得商，接着用商除 X，直到商为 0，余数倒过来写。 X 进制 -&gt; 十进制：乘。从数的个位开始，依次乘以 X 的 0 次方，1 次方……，最后加起来。 十进制 -&gt; 十六进制 12345610 进制数：3333 / 16 = 2 ...... 1 2 / 16 = 0 ...... 2转换成 16 进制数：21 十六进制 -&gt; 十进制 1234516 进制数：211 * 16⁰ + 2 * 16¹ = 33转换成 10 进制数：33 十进制 -&gt; 八进制 12345610 进制数：1919 / 8 = 2 ...... 3 2 / 8 = 0 ...... 2转换成 8 进制数：23 八进制 -&gt; 十进制 123458 进制数：233 * 8⁰ + 2 * 8¹ = 19转换成 10 进制数：19 十进制 -&gt; 二进制 1234567891010 进制数：4646 / 2 = 23 ...... 023 / 2 = 11 ...... 111 / 2 = 5 ...... 1 5 / 2 = 2 ...... 1 2 / 2 = 1 ...... 0 1 / 2 = 0 ...... 1转换成 2 进制数：101110 二进制 -&gt; 十进制 123452 进制数：1011100 * 2⁰ + 1 * 2¹ + 1 * 2² + 1 * 2³ + 0 * 2⁴ + 1 * 2⁵ = 46转换成 10 进制数：46]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（三）运算符、语句、编程形式]]></title>
    <url>%2F2019%2F07%2F07%2F%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%AF%AD%E5%8F%A5%E3%80%81%E7%BC%96%E7%A8%8B%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[运算符算术运算符 +：数学运算；字符串连接：任何数据类型加字符串都等于字符串。 1234567// 从左至右运算// 1+1 数字运算，得 2// 2+'a' 字符串连接，得 2a// '2a'+1 字符串连接，得 2a1// 同理可得 2a11var result = 1 + 1 + 'a' + 1 + 1;console.log(result); // 2a11 -、*、/、%、=、() +=、-=、/=、*=、%= ++。先加加（减减）还是后加加（减减）是针对当前语句来说的。++放后面，意为先执行该条语句，然后再加加。++放前面，意为先加加，然后再执行该条语句。 1234567var a = 10;console.log(a++); // 10// 意为先执行 console.log(a)，执行完后 a++//此时再看 a 的值，就是加完之后的了console.log(a); // 11 1234567891011var a = 10;var b = ++a - 1 + a++; // ++a 先加后执行，10 + 1 = 11，a 的值变为 11// a++ 先执行后加，a 现在的值为 11 ，故 a++ = 11// b = 11 - 1 + 11 = 21console.log(b);// 21// a 两次自增，故值为 12console.log(a);// 12 --。注意：有前自增（自减）操作符时，要先加加（减减），再执行该条语句。 1234567891011var a = 1;var b = a-- + --a; // 先算 --a，先减后执行，a = 1，自减后 a = 0// 再算 a--，先执行后减，a = 0，故 a-- = 0// b = 0 + 0 = 0console.log(b);// 0// a 两次自减，故值为 -1console.log(a);// -1 比较运算符 &gt;、&lt;、==、&gt;=、&lt;=、!= 比较结果为 boolean 值：true / false。 注意，==是等于，而=是赋值。 字符串的比较规则为 asc 码。如“A”的 asc 码为 65 ，“a”的 asc 码为 97。 字符串比较是按照顺序来的，如果运算符左边的字符串中顺位第一的字符小于右边字符串的第一位字符，那么左边直接就是小于右边；如果第一位相等，那就再看第二位。 12345678910// 读作字符串一零 &gt; 字符串二var result = '10' &gt; '2';console.log(result); // false// 字符串‘1’的 asc 码为 49// 字符串‘2’的 asc 码为 50// 字符串‘3’的 asc 码为 51var result = '3' &gt; '20';console.log(result); // true 逻辑运算符 &amp;&amp;、||、! 运算结果为真实的值 下面六个值转化为布尔值都是 false：undefined、null、NaN、&quot;&quot;、0、flase。其中 NaN(Not a Number)：非数，是数字类型的一类值，意为不可表示的值。 注意：&amp;&amp;在运行时，在碰到表达式的布尔值为假时，返回该表达式的值。 多个表达式时，先看第一个表达式转换成布尔值的结果，若结果为真，接着看第二个表达式的布尔值，若第二个也为真，接着看第三个，依此类推，直到表达式的布尔值为 false，直接返回该表达式的值。即看到假，返回假。如果全为真，则返回最后一个表达式的值。 只有两个表达式时，若第一个表达式的布尔值为 true，返回第二个表达式的值。若第一个表达式为 false，直接返回第一个表达式原本的值。即一真返二。一假返一。 12345var a = 1 &amp;&amp; 2; console.log(a); // 2// 1 转化为 true，判断为真// 第一个为 true，直接返回第二个表达式的值 基于&amp;&amp;运算符的原理， 使它具备中断的作用，在实际开发中作为短路语句使用，它是 if 语句的简写形式，可以用来替代 if 语句：“如果…是真/假，那么…” 123450 &amp;&amp; document.write('a'); // 不会输出 a// 如果前面的数据正确，那么执行后面的语句2 &gt; 1 &amp;&amp; console.log('团子很可爱'); // 团子很可爱 ||与&amp;&amp;类似，只不过是碰到表达式的布尔值为真时，返回该表达式的值。 多个表达式时，若第一个为假，则一直往下看，直到找到为真的表达式，然后返回该值。即看到真，返回真。如果全为假，则返回最后一个表达式的值。 两个表达式时，若第一个为假，直接返回第二个表达式的值。 123var num = 1 || 3;console.log(num); // 1 !将表达式转换成布尔值再取反，然后输出布尔值。 其他：逗号运算符 形式：(表达式1，表达式2，表达式3………….) 作用：通常与小括号()一起使用，逗号,用于连接算式 运算规则：对每个操作对象求值（从左至右），返回最后一个操作对象的值。 1234567var a = 10, b = 20, result = (a++, a + b);console.log (result); // 31 console.log (a); // 11console.log (b); // 20 查询运算符优先级。 语句if 条件语句 if (条件判断) {执行语句} if () {} else if () {} if () {}&lt;—&gt; &amp;&amp;转换 for 循环语句 for 循环执行顺序： 12345678910// (1) (2) (4)for (var i = 0; i &lt; 10; i++) &#123; console.log('a'); // (3)&#125;var i = 0; // (1)for (; i &lt; 10; ) &#123; // (2) console.log('a'); // (3) i++; // (4)&#125; 先执行一遍 (1) ：var i = 0 判断 (2) -&gt; 执行语句 (3)：if(i &lt; 10){console.log(&#39;a&#39;);} 执行 (4)：i++ -&gt; i = 1 判断 (2) -&gt; 执行语句 (3) 执行 (4)：i++ -&gt; i = 2 判断 (2) -&gt; 执行语句 (3) 执行 (4)：i++ -&gt; i = 3 注意：无论 for 语句中写的是什么，都会按照这个执行顺序执行。 while 12345var i = 0;while (i &lt; 10) &#123; console.log(i); i++;&#125; do while（很少用） 12345var i = 0;do &#123; console.log('a'); i++;&#125; while (i &lt; 10) switch 语句 格式： 12345678910111213switch (条件) &#123; case 结果1: // 结果与条件进行判断（比对） 执行语句; // 满足即执行该语句 break; // 执行后结束 case 结果2: 执行语句; break; case 结果3: 执行语句; break; default: 执行语句;&#125; switch 的条件和 case 的结果比对，如果是一样的，就执行。 1234567891011121314var date = window.prompt('input');switch (date) &#123; case 'monday': case 'tuesday': case 'wednesday': case 'thursday': case 'friday': console.log('working'); break; case '周六': case '周日': console.log('relaxing'); break;&#125; 当 case 的结果是表达式时，比较的就是表达式的返回值。 1234567891011121314151617var age = 28, greeting;switch (true) &#123; // 条件 case age &lt; 18: // 结果1 greeting = '同学'; break; case age &gt;= 18 &amp;&amp; age &lt; 40: // 结果2 greeting = '先生'; break; case age &gt;= 40: greeting = '前辈'; break; default: greeting = '你好';&#125;console.log(greeting); // '先生' 补充 break：终止循环。注意，必须写在循环里面，写在外面会报错。 123456789var sum = 0;for (var i = 0; i &lt; 100; i++)&#123; sum += i; console.log(i); if (sum &gt; 100) &#123; break; // 这个 break 能执行是因为最外有一层 for 循环，如果只有 if 语句，是肯定报错的 &#125;&#125; continue：终止本次循环，直接进行下一次循环。 123456for (var i = 0; i &lt; 100; i++) &#123; if (i % 7 === 0 || i % 10 === 7) &#123; continue; &#125; console.log(i);&#125; 编程形式 面向过程：C 面向对象：Java、C++ 既面向对象也面向过程：JavaScript]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）变量、值类型、语句基本规则]]></title>
    <url>%2F2019%2F07%2F05%2F%E4%BA%8C%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E5%80%BC%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[变量（variable）变量声明： 声明、赋值分解 12var a;a = 1; 单一 var 12var a = 1, b = 2; 开发规范：单一 var 模式，每个变量用逗号隔开，同时换行。 命名规则： 变量名必须以英文字母、_、$开头 变量名可以包括英文字母、_、$、数字 不可以用系统的关键字、保留字作为变量名。 值类型：原始值与引用值原始值 不可改变， 存储在 stack（栈）：先进的后出来。 五大值类型： Number — 数字 Boolean — 布尔 String — 字符串 undefined — 未定义（未被赋值的变量值输出时会有这个结果） null — 空（可以用来占位） 引用值 存储在 heap（堆）：怎么进的怎么出。 值类型： Array — 数组 Object — 对象 Function — 函数 RegExp — 正则 Date — 日期 区别 原始值和引用值唯一的不同是赋值形式不同。 原始值以值的拷贝方式赋值，原值是不可变的。操作都在副本上。引用值以引用的拷贝方式赋值，原值是可变的。引用的是地址，操作还是在原来的地方，除非换一个地址（赋新值）。 原始值一旦赋值，不可更改。无论是原值增删，还是新的赋值，都会直接存放到新的地方，原值不动。在操作上，表现为原始值和对应栈名复制一份到新的地方，同时之前的对应栈名初始化，值不动，增删和新赋值都在副本上进行。如： 在栈内存中声明一个叫 num 的房间，放入值 1 在栈内存中声明一个叫 num1 的房间，拷贝 num 的值 1 放入 num1 将 num 及其值 1 拷贝到一个新的房间，然后修改值为 2，原来的房间名初始化为 1005，原值 1 依然留在该房间，不会发生变化 12345var num = 1, num1 = num;num = 2;console.log(num1); // 1 引用值赋值之后，如果是在原值上增删，会直接修改原值。如果是新的赋值，就会直接存放到新的地方，原值不动。 原值增删： 在栈内存中声明一个叫 arr 的房间，在堆内存中一个房间里放入值 [1, 2]，然后 arr 房间内放入这个值的==堆内存地址==heap1001 在栈内存中声明一个叫 arr1 的房间，然后直接拷贝 arr 房间内存放的地址heap1001，获得 arr 的值 此时 arr 与 arr1 指向同一个值的地址heap1001 arr 增加新值 3，直接在heap1001存放的值里增加，变为 [1, 2, 3] 此时 arr 与 arr1 共同指向的值变为 [1, 2, 3] 12345var arr = [1, 2], arr1 = arr;arr.push(3);document.write(arr1); // [1, 2, 3] 赋新值： 在栈内存中声明一个叫 arr 的房间，在堆内存中一个房间里放入值 [1, 2]，然后 arr 房间内放入堆内存地址heap1001 在栈内存中声明一个叫 arr1 的房间，然后直接拷贝 arr 房间内存放的地址，获得 arr 的值 此时 arr 与 arr1 指向同一个值的地址heap1001 arr 赋新值，在堆内存中另一个房间里放入新值 [1, 2, 3]，然后 arr 房间内删除原来的地址heap1001，放入这个新值的堆内存地址heap1002 此时 arr 指向的值为 [1, 2, 3]，arr1 指向的值为 [1, 2] 1234var arr = [1,2], arr1 = arr;arr = [1,2,3];document.write(arr1); // [1, 2] JS 语句基本规则 语句后面要用分号;结束。注意，下列三种语句不用加分号： 函数： function test() {} for 循环：for() {} if 语句：if() {} 一个 HTML 文件中可以放多个 JS 代码块，代码块内的规则可以互通。如果某个代码块内出现 JS 语法错误，会引发该代码块内的后续代码终止，但不会影响其他 JS 代码块，目前有两种错误： 低级错误：语法解析错误，整个代码块都不会执行。如：使用了中文标点符号：Uncaught Syntax Error: …… 逻辑错误：标准错误，会执行到该代码块最后一行正确代码再终止。如：没有声明变量，直接使用：Uncaught Reference Error: …… 书写格式要规范，= + / -两边都应该有空格。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）JavaScript 基础知识]]></title>
    <url>%2F2019%2F07%2F03%2F%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[浏览器 Mosaic 是互联网历史上第一个获普遍使用和能够显示图片的网页浏览器。于 1993 年问世。 浏览器组成： shell （外形）部分 内核部分：渲染引擎（语法规则和渲染），js 引擎，其他模块 主流浏览器及其内核： IE -&gt; Trident Chrome -&gt; Blink Opera -&gt; Blink Safari -&gt; Webkit Firefox -&gt; Gecko 2001 年的 IE6 浏览器，首次实现对 JavaScript 引擎的优化和分离。 2008 年 Google 发布最新浏览器 Chrome，它是采用优化后的 JavaScript 引擎，引擎代号 V8，因能把 JavaScript 代码直接转化为机械码来执行，进而以速度快而闻名。 特性 程序设计语言分为解释型和编译型两大类。 C 或 C++ 等语言需要一个编译器（compiler）。编译器是一种程序，能够把用 Java 等高级语言编写出来的源代码翻译为直接在计算机上执行的文件。 解释型程序设计语言不需要编译器，它们只需要解释器。对于 JavaScript，浏览器负责完成有关的解释和执行工作。 特点： 解释型语言 — （不需要编译成文件）跨平台。 单线程 — 同一时间只能干一件事。 弱类型语言 — 存放的数据类型可变。 我们把 JavaScript 中的核心部分称为 ECMAScript，加上 BOM（浏览器对象模型）与 DOM（文档对象类型），三者共同组成了 JavaScript。 ECMA-262 标准规定了这门语言的如下组成部分：语法、类型、语句、关键字、保留字、操作符、对象。 浏览器对象模型（BOM，Browser Object Model），提供与浏览器交互的方法和接口。 文档对象内容（DOM，Document Object Model），提供访问和操作网页内容的方法和接口。 异步（asynchronous）：同时执行，类似于有很多条路一起走，可以同时出发。 同步（synchronous）：分次执行，类似于只有一条路走，这个走完了下个才能走。 JavaScript 执行队列 -&gt; 执行过程：轮转时间片。 单线程模拟多线程。 类似吃饭，吃一口米饭，吃一口茄子，再吃一口排骨，再吃一口米饭，再吃一口米饭，再吃一口茄子，顺序完全随机，在足够快的时间内，肉眼可见菜和饭在同时减少。 比如 js 引擎要执行任务 1 和任务 2，js 引擎会把任务 1 和任务 2 切成无数个片段，然后把这些片段随机排成一个队列送入引擎执行，直到被执行完。 JavaScript 可正常计算的范围：小数点前 16 位，后 16 位。 JS 计算精度不准，是纯粹的 bug，所以在 JS 中应尽量避免小数操作。 123var num = 0.14 * 100;console.log(num); // 14.000000000000002 如果需要计算，那么采用Math.floor()（向下取整）或Math.ceil()（向上取整）方法。 123456789// 向上取整，无论小数是多少，都向前进 1var num = Math.ceil(123.234);console.log(num); // 124// 向下取整，无论小数是多少，都不要了var num1 = Math.floor(123.999);console.log(num1); // 123 Math.random()方法可以随机产生一个 0 ～ 1 之间的开区间的数。 12345var num = Math.random();console.log(num); // 0.4322440432127299console.log(num); // 0.5216225452503296 toFixed()方法可以把 Number 四舍五入为指定小数位数的数字。 12345var num = 123.45678; demo = num.toFixed(2); console.log(demo); // 123.46 引入 JavaScript： 页面内嵌&lt;script&gt;&lt;/script&gt;标签 外部引入&lt;script src=location&gt;&lt;/script&gt; 页面中，可以存在多个&lt;script&gt;标签，执行顺序从上到下。只要不存在 defer 和 async 属性，浏览器都会按照 它们在页面中出现的先后顺序依次进行解析。 注意，如果有外部 js 文件，那么这个 script 标签里如果再写 js 代码，也是不会执行的，会被直接忽略。基于这个特性，在开发时偶尔会用来存储一些代码。 在下面再写一个 script 标签，然后里面写代码是可以的。 传统的做法是所有&lt;script&gt;标签都放在&lt;head&gt;中，这意味着必须等到全部 js 代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到&lt;body&gt;标签时才开始呈现内容）。 为了避免这个问题，现代 Web 应用程序一般都把全部 js 引用放在&lt;body&gt;中页面内容的后面。这样，在解析包含的 js 代码之前，页面的内容将完全呈现在浏览器中。而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快了。 为符合 Web 标准中结构、样式、行为相分离的原则，通常会采用外部引入。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo!This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
